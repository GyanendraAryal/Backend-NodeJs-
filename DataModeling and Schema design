# Notes: Data Modeling, Schema & Models in Mongoose

> Based on: *Chai aur Backend* series — JavaScript Backend with MongoDB & Mongoose

---

## 1. The Right Mindset Before Building a Backend

Before writing any code (login, controllers, routes), the **most important first question** is:

> **"What data am I going to store, and what are its fields?"**

Most beginners jump straight into writing login/signup controllers. Experienced developers pause and ask:
- What data points need to be stored?
- What is the format/type of each field?
- How are these fields related to each other?

Only after answering these questions should you move forward.

> Choosing between MySQL, MongoDB, PostgreSQL, etc. is a **secondary decision** — data structure comes first.

---

## 2. What is Data Modeling?

**Data modeling** is the process of defining:
- Which entities (users, todos, products, patients) exist in your system
- What fields/properties each entity holds
- How entities relate to one another

### Practical Approach (No Tools Needed)
Use **pen and paper**. Sketch out your registration/input forms. Each form field = a potential database field.

**Example — Registration Form fields:**
- `username` → String
- `email` → String
- `password` → String

Adding just **one more field** (e.g., a profile `photo`) changes the entire logic of your backend. This is why clarity upfront saves rework later.

---

## 3. Professional Data Modeling Tools

| Tool | Description |
|------|-------------|
| **Moon Modeler** | Paid (~$99–$150). Generates Mongoose schema code automatically. Used widely in corporates. |
| **Eraser (eraser.io)** | Free tier available. ER diagram tool with code-style syntax. Good for visual modeling. |
| **Pen & Paper / Whiteboard** | Always available, always works. Best starting point for any project. |

> In large companies, there are dedicated **Database Specialists / Data Architects** who define the data model before developers write a single line of code.

---

## 4. Introduction to Mongoose

**Mongoose** is an *elegant MongoDB object modeling library* for Node.js.

- It acts as a **helper layer** between your code and MongoDB.
- It allows you to define the **structure, types, and validation rules** of your data.
- Similar tools: **Prisma** (for SQL databases), **TypeORM**, etc.

Install it via:
```bash
npm install mongoose
```

---

## 5. Core Concepts: Schema vs. Model

### Schema
A **Schema** defines the *blueprint* — the shape and rules of your data.

```javascript
import mongoose from "mongoose";

const userSchema = new mongoose.Schema({
  // field definitions go here
});
```

- `new mongoose.Schema({})` accepts an **object** containing field definitions.
- A schema does **not** directly interact with the database — it's just a blueprint.

### Model
A **Model** is the *compiled version* of a schema. It provides an interface to interact with a MongoDB collection.

```javascript
export const User = mongoose.model("User", userSchema);
```

- `mongoose.model()` takes two arguments:
  1. **Model name** (string) — e.g., `"User"`, `"Todo"`
  2. **Schema** — the schema this model is based on

> **Important:** When a model named `"User"` is registered, MongoDB stores it as a collection named **`users`** (lowercase + plural). This is Mongoose's default behavior.

---

## 6. The 3-Line Boilerplate (Always the Same)

Every Mongoose model file follows this exact pattern:

```javascript
// Step 1: Import Mongoose
import mongoose from "mongoose";

// Step 2: Define the Schema
const userSchema = new mongoose.Schema({
  // ...field definitions
}, { timestamps: true });

// Step 3: Export the Model
export const User = mongoose.model("User", userSchema);
```

This structure **never changes** regardless of what you're modeling.

---

## 7. Defining Fields in a Schema

### Simple (Shorthand) Syntax
```javascript
const userSchema = new mongoose.Schema({
  username: String,
  email: String,
  isActive: Boolean,
});
```

### Professional (Object) Syntax
The object syntax unlocks Mongoose's validation superpowers:

```javascript
const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
  },
  password: {
    type: String,
    required: [true, "Password is required"], // custom error message
  },
  isActive: {
    type: Boolean,
    default: false,
  },
});
```

### Common Field Options

| Option | Description | Example |
|--------|-------------|---------|
| `type` | Data type of the field | `String`, `Number`, `Boolean`, `Date` |
| `required` | Field must be present | `true` or `[true, "Error message"]` |
| `unique` | Value must be unique in collection | `true` |
| `lowercase` | Auto-converts to lowercase | `true` |
| `default` | Default value if not provided | `false`, `0`, `""` |
| `min` / `max` | Numeric range validation | `min: 0`, `max: 100` |

---

## 8. Timestamps

Almost every model needs `createdAt` and `updatedAt` fields. Mongoose handles this automatically:

```javascript
const userSchema = new mongoose.Schema({
  // ...fields
}, { timestamps: true }); // ← second argument to Schema constructor
```

- This adds two fields automatically: `createdAt` and `updatedAt`
- Note: it is `timestamps` (plural), **not** `timestamp`

---

## 9. Relationships Between Models (References)

In MongoDB/Mongoose, relationships are handled using **references** (not foreign keys like SQL).

When a field in one model refers to a document in another model:

```javascript
createdBy: {
  type: mongoose.Schema.Types.ObjectId, // special type
  ref: "User",                           // reference to the "User" model
}
```

- `mongoose.Schema.Types.ObjectId` is a **special type** that signals a reference
- `ref` tells Mongoose **which model** this ID belongs to
- The value passed to `ref` must match **exactly** the name used in `mongoose.model("User", ...)`

---

## 10. Arrays of Sub-Documents

When a field holds **multiple related objects** (e.g., a Todo containing many sub-todos):

```javascript
subTodos: [
  {
    type: mongoose.Schema.Types.ObjectId,
    ref: "SubTodo",
  }
]
```

- Square brackets `[ ]` define an **array**
- Inside, define the type of each element
- If each element is an object reference, use `ObjectId` + `ref`

---

## 11. Complete Example — Todo Application Models

### User Model (`user.model.js`)
```javascript
import mongoose from "mongoose";

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
  },
  password: {
    type: String,
    required: true,
  },
}, { timestamps: true });

export const User = mongoose.model("User", userSchema);
```

### Todo Model (`todo.model.js`)
```javascript
import mongoose from "mongoose";

const todoSchema = new mongoose.Schema({
  content: {
    type: String,
    required: true,
  },
  complete: {
    type: Boolean,
    default: false,
  },
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
  },
  subTodos: [
    {
      type: mongoose.Schema.Types.ObjectId,
      ref: "SubTodo",
    }
  ], // Array of SubTodo references
}, { timestamps: true });

export const Todo = mongoose.model("Todo", todoSchema);
```

### SubTodo Model (`subtodo.model.js`)
```javascript
import mongoose from "mongoose";

const subTodoSchema = new mongoose.Schema({
  content: {
    type: String,
    required: true,
  },
  complete: {
    type: Boolean,
    default: false,
  },
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
  },
}, { timestamps: true });

export const SubTodo = mongoose.model("SubTodo", subTodoSchema);
```

---

## 12. File Naming Convention

In professional codebases, model files follow this naming pattern:

```
user.model.js
todo.model.js
subtodo.model.js
```

The `.model.` part is a **naming convention** — it signals that this file is a data model. The file is still a regular JavaScript file.

Similarly, controller files use `.controller.js`, and so on. **Consistency** in naming is critical.

---

## 13. Key Takeaways

1. **Data modeling comes before everything** — before routes, controllers, and database connection.
2. A **Schema** is just a blueprint; a **Model** is what creates/queries the collection.
3. Always use the **object syntax** for field definitions in production code — it gives you validation for free.
4. Use `{ timestamps: true }` to auto-track `createdAt` and `updatedAt`.
5. Use `mongoose.Schema.Types.ObjectId` with a `ref` to link documents across collections.
6. MongoDB collection names are auto-derived: `"User"` → `users`, `"Todo"` → `todos`.
7. The 3-step boilerplate (import → define schema → export model) is **always the same**.

---

*Next: Modeling more complex systems — E-Commerce & Hospital Management data models.*
